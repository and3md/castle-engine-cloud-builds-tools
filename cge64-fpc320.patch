diff --git a/src/3d/castleboxes.pas b/src/3d/castleboxes.pas
index 5008efb..3e13566 100644
--- a/src/3d/castleboxes.pas
+++ b/src/3d/castleboxes.pas
@@ -113,12 +113,11 @@ type
   public
     Data: array [0..1] of TVector3;
 
-    const
-      { Special TBox3D value meaning "bounding box is empty".
-        This is different than just bounding box with zero sizes,
-        as bounding box with zero sizes still has some position.
-        Empty bounding box doesn't contain any portion of 3D space. }
-      Empty: TBox3D = (Data: ((Data: (0, 0, 0)), (Data: (-1, -1, -1))));
+    { Special TBox3D value meaning "bounding box is empty".
+      This is different than just bounding box with zero sizes,
+      as bounding box with zero sizes still has some position.
+      Empty bounding box doesn't contain any portion of 3D space. }
+    class function Empty: TBox3D; static;
 
     { Check is box empty.
       You can think of this function as "compare Box with TBox3D.Empty".
@@ -703,6 +702,13 @@ begin
   Data[1] := Value;
 end;
 
+class function TBox3D.Empty: TBox3D;
+const
+  R: TBox3D = (Data: ((Data: (0, 0, 0)), (Data: (-1, -1, -1))));
+begin
+  Result := R;
+end;
+
 function TBox3D.IsEmpty: boolean;
 begin
   Result := Data[0].Data[0] > Data[1].Data[0];
diff --git a/src/3d/castlequaternions.pas b/src/3d/castlequaternions.pas
index bc6ace7..9f45dc3 100644
--- a/src/3d/castlequaternions.pas
+++ b/src/3d/castlequaternions.pas
@@ -39,12 +39,11 @@ type
             Vector4: TVector4);
     end;
 
-    const
-      { Quaternion representing @italic("no rotation").
-        Note: this is @italic(not) a quaternion filled with zeros
-        (the @code(Data.Real) component is 1.0), instead this is a unit quaternion
-        that correctly represents @italic("rotation by zero degrees/radians"). }
-      ZeroRotation: TQuaternion = (Data: (Vector: (Data: (0, 0, 0)); Real: 1));
+    { Quaternion representing @italic("no rotation").
+      Note: this is @italic(not) a quaternion filled with zeros
+      (the @code(Data.Real) component is 1.0), instead this is a unit quaternion
+      that correctly represents @italic("rotation by zero degrees/radians"). }
+    class function ZeroRotation: TQuaternion; static;
 
     { Calculate axis (will be normalized) and angle (will be in radians)
       of rotation encoded in unit quaternion Q.
@@ -182,6 +181,13 @@ uses Math, CastleUtils;
 
 { TQuaternion ---------------------------------------------------------------- }
 
+class function TQuaternion.ZeroRotation: TQuaternion; static;
+const
+  R: TQuaternion = (Data: (Vector: (Data: (0, 0, 0)); Real: 1));
+begin
+  Result := R;
+end;
+
 procedure TQuaternion.ToAxisAngle(out Axis: TVector3;
   out AngleRad: Single);
 { Data is a normalized quaternion, so
diff --git a/src/base/castleconf.inc b/src/base/castleconf.inc
index 27a0344..6f1d22c 100644
--- a/src/base/castleconf.inc
+++ b/src/base/castleconf.inc
@@ -142,22 +142,25 @@
   {$undef ALLOW_DLOPEN_FROM_UNIT_INITIALIZATION}
 {$endif}
 
-// This serves two purposes:
+// *Not* define ENABLE_SELF_RECORD_CONSTANTS because:
+//
 // - Declaring something like TVector3.Zero (constant filled with zeros,
 //   inside a record, which type is the same record)
 //   causes internal error in FPC 3.0.2, 3.0.4 (not in 3.0.0 or 3.1.1,
 //   so already fixed in FPC).
+//
 // - Declaring something like TVector3.Zero or TVector3.One
 //   (any constant inside a record, which type is the same record)
 //   is not allowed in Delphi, causes error that type is not completely defined.
-{$ifdef FPC}
-  {$define ENABLE_SELF_RECORD_CONSTANTS}
-  {$ifdef VER3_0}
-    {$ifndef VER3_0_0}
-      {$undef ENABLE_SELF_RECORD_CONSTANTS}
-    {$endif}
-  {$endif}
-{$endif}
+//
+// - Since FPC 3.3.1 (at least revision 40292, revision 40000 was OK)
+//   FPC reports the same error as Delphi
+//   (Error: Type "TGenericVector2" is not completely defined).
+//
+// So ENABLE_SELF_RECORD_CONSTANTS is just *never* defined for now.
+// If FPC 3.3.1 will keep this behaviour, we'll just simplify the code
+// in the future to not make this optional.
+{.$define ENABLE_SELF_RECORD_CONSTANTS}
 
 // Workaround FPC 3.0.0 bug (not present in 3.0.2, 3.0.4, 3.1.1 -- so already fixed).
 {$ifdef VER3_0_0}
diff --git a/src/base/castleparameters.pas b/src/base/castleparameters.pas
index ef905a7..5da2e6a 100644
--- a/src/base/castleparameters.pas
+++ b/src/base/castleparameters.pas
@@ -98,7 +98,7 @@ const
 type
   { Callback used by TParameters.Parse to notify about new option.
 
-    @param(OptionNum The option number in the Options table (zero-based).)
+    @param(OptionNum The option number in the AOptions table (zero-based).)
 
     @param(HasArgument Says if you have a single argument in the Argument
       parameter. Always @false when your option has oaNone or
@@ -159,7 +159,7 @@ type
         They can be modified to remove the already-handled parameters.)
 
       @itemLabel @italic(Option)
-      @item(Options are things encoded by the user in the parameters.
+      @item(AOptions are things encoded by the user in the parameters.
         Examples:
 
         @unorderedList(
@@ -237,7 +237,7 @@ type
     function IsPresent(const A: array of string): boolean;
 
     { Parse command-line parameters. Given a specification of your command-line
-      options (in Options), we will find and pass these options to your
+      options (in AOptions), we will find and pass these options to your
       OptionProc callback. The handled options will be removed from
       the @link(Parameters) list.
 
@@ -301,10 +301,10 @@ type
       in some weird situations.
 
       @groupBegin }
-    procedure Parse(Options: POption_Array; OptionsCount: Integer;
+    procedure Parse(AOptions: POption_Array; OptionsCount: Integer;
       OptionProc: TOptionProc; OptionProcData: Pointer;
       ParseOnlyKnownLongOptions: boolean = false); overload;
-    procedure Parse(const Options: array of TOption;
+    procedure Parse(const AOptions: array of TOption;
       OptionProc: TOptionProc; OptionProcData: Pointer;
       ParseOnlyKnownLongOptions: boolean = false); overload;
     { @groupEnd }
@@ -403,10 +403,10 @@ begin
   Result := false;
 end;
 
-procedure TParameters.Parse(const Options: array of TOption; OptionProc: TOptionProc;
+procedure TParameters.Parse(const AOptions: array of TOption; OptionProc: TOptionProc;
   OptionProcData: Pointer; ParseOnlyKnownLongOptions: boolean);
 begin
-  Parse(@Options, System.High(Options)+1, OptionProc, OptionProcData,
+  Parse(@AOptions, System.High(AOptions)+1, OptionProc, OptionProcData,
     ParseOnlyKnownLongOptions);
 end;
 
@@ -451,7 +451,7 @@ begin
 end;
 
 procedure TParameters.Parse(
-  Options: POption_Array; OptionsCount: Integer; OptionProc: TOptionProc;
+  AOptions: POption_Array; OptionsCount: Integer; OptionProc: TOptionProc;
   OptionProcData: Pointer; ParseOnlyKnownLongOptions: boolean);
 
   function ParseLongParameter(const s: string; out HasArgument: boolean;
@@ -461,7 +461,7 @@ procedure TParameters.Parse(
     zero-based), wyciaga tez zapisany razem z nia parametr i zwraca
     HasArgument i Argument (pamietaj ze wyciaga tylko argumenty dolaczone
     do opcji przy pomocy znaku "="; nie sprawdza tez w ogole czy HasArgument
-    w jakis sposob zgadza sie z Options[result].Argument.).
+    w jakis sposob zgadza sie z AOptions[result].Argument.).
 
     Jezeli ParseOnlyKnownLongOptions to moze zwrocic -1 aby zaznaczyc ze
     ten parametr nie reprezentuje zadnej znanej opcji (chociaz ciagle
@@ -472,7 +472,7 @@ procedure TParameters.Parse(
   begin
    SplitLongParameter(s, ParamLong, HasArgument, Argument, 2);
    for i := 0 to OptionsCount-1 do
-    if Options^[i].Long = ParamLong then
+    if AOptions^[i].Long = ParamLong then
      begin result := i; Exit; end;
 
    if ParseOnlyKnownLongOptions then
@@ -481,7 +481,7 @@ procedure TParameters.Parse(
   end;
 
   function FindShortOption(c: char; const Parameter: string): Integer;
-  { znajdz takie i ze Options[i].Short = c (i c <> #0).
+  { znajdz takie i ze AOptions[i].Short = c (i c <> #0).
     Jesli sie nie uda - wyjatek EInvalidshortOption.
     Parametr "Parameter" jest nam potrzebny
     _tylko_ zeby skomponowac ladniejszy (wiecej mowiacy) Message wyjatku,
@@ -493,7 +493,7 @@ procedure TParameters.Parse(
     raise EInvalidShortOption.CreateFmt(SInvalidShortOpt, ['#0 (null char)', Parameter]);
 
    for result := 0 to OptionsCount-1 do
-    if Options^[result].Short = c then Exit;
+    if AOptions^[result].Short = c then Exit;
 
    raise EInvalidShortOption.CreateFmt(SInvalidShortOpt, [c, Parameter]);
   end;
@@ -508,9 +508,9 @@ procedure TParameters.Parse(
     podane razem z ostatnia opcja (czyli z opcja zwracana pod nazwa).
     Te proste opcje zostaly "skombinowane" razem z ostatnia opcja w
     jednym parametrze. W rezultacie nazywam je "prostymi" bo one nie moga
-    miec argumentu - Options^[].Argument tych opcji moze byc tylko oaNone
+    miec argumentu - AOptions^[].Argument tych opcji moze byc tylko oaNone
     lub oaOptional. Ta procedura NIE sprawdza ze to sie zgadza
-    tak jak w ogole nie sprawdza zadnego Options^[].Argument, takze
+    tak jak w ogole nie sprawdza zadnego AOptions^[].Argument, takze
     dla ostatniej (zwracanej pod nazwa) opcji nie sprawdza - moze wiec
     zwrocic opcje oaNone z HasArgument albo oaRequired[*Separate] z
     not HasArgument.
@@ -569,12 +569,12 @@ begin
     if SCharIs(Strings[i], 2, '-') then
     begin
      OptionNum := ParseLongParameter(Strings[i], HasArgument, Argument);
-     if OptionNum <> -1 then OptionName := '--'+Options^[OptionNum].Long;
+     if OptionNum <> -1 then OptionName := '--'+AOptions^[OptionNum].Long;
     end else
     if not ParseOnlyKnownLongOptions then
     begin
      OptionNum := ParseShortParameter(Strings[i], HasArgument, Argument, SimpleShortOptions);
-     OptionName := '-'+Options^[OptionNum].Short;
+     OptionName := '-'+AOptions^[OptionNum].Short;
     end;
    end;
 
@@ -589,9 +589,9 @@ begin
     { najpierw zajmij sie SimpleShortOptions }
     for k := 0 to SimpleShortOptions.Count-1 do
     begin
-     if not (Options^[SimpleShortOptions[k]].Argument in [oaNone, oaOptional]) then
+     if not (AOptions^[SimpleShortOptions[k]].Argument in [oaNone, oaOptional]) then
       raise EMissingOptionArgument.Create('Missing argument for short option -'+
-        Options^[SimpleShortOptions[k]].Short +'; when combining short options only the last '+
+        AOptions^[SimpleShortOptions[k]].Short +'; when combining short options only the last '+
         'option can have an argument');
      OptionProc(SimpleShortOptions[k], false, '', EmptySeparateArgs, OptionProcData);
     end;
@@ -605,7 +605,7 @@ begin
     { upewnij sie ze HasArgument ma dopuszczalna wartosc. Odczytaj argumenty
       podane jako osobne paranetry dla oaRequired i oaRequired?Separate. }
 
-    if (Options^[OptionNum].Argument = oaRequired) and (not HasArgument) then
+    if (AOptions^[OptionNum].Argument = oaRequired) and (not HasArgument) then
     begin
      if i > High then
       raise EMissingOptionArgument.Create('Missing argument for option '+OptionName);
@@ -613,22 +613,22 @@ begin
      Argument := Strings[i];
      Delete(i);
     end else
-    if (Options^[OptionNum].Argument = oaNone) and HasArgument then
+    if (AOptions^[OptionNum].Argument = oaNone) and HasArgument then
      raise EExcessiveOptionArgument.Create('Excessive argument for option '+OptionName) else
-    if Options^[OptionNum].Argument in OptionArgumentsRequiredSeparate then
+    if AOptions^[OptionNum].Argument in OptionArgumentsRequiredSeparate then
     begin
      if HasArgument then
       raise EExcessiveOptionArgument.CreateFmt('Option %s requires %d arguments, '+
         'you cannot give them using the form --option=argument, you must give '+
         'all the arguments as separate parameters', [OptionName,
-        OptionSeparateArgumentToCount(Options^[OptionNum].Argument) ]);
+        OptionSeparateArgumentToCount(AOptions^[OptionNum].Argument) ]);
 
-     for j := 1 to OptionSeparateArgumentToCount(Options^[OptionNum].Argument) do
+     for j := 1 to OptionSeparateArgumentToCount(AOptions^[OptionNum].Argument) do
      begin
       if i > High then
        raise EMissingOptionArgument.CreateFmt('Not enough arguments for option %s, '+
          'this option needs %d arguments but we have only %d', [OptionName,
-         OptionSeparateArgumentToCount(Options^[OptionNum].Argument), j-1]);
+         OptionSeparateArgumentToCount(AOptions^[OptionNum].Argument), j-1]);
       SeparateArgs[j] := Strings[i];
       Delete(i);
      end;
diff --git a/src/base/castleutils_struct_list.inc b/src/base/castleutils_struct_list.inc
index af2e742..2dcf15c 100644
--- a/src/base/castleutils_struct_list.inc
+++ b/src/base/castleutils_struct_list.inc
@@ -24,7 +24,7 @@ type
   TStructList<T> = class({$ifdef CASTLE_OBJFPC}specialize{$endif} TList<T>)
   public
     type
-      PT = ^T;
+      PtrT = ^T;
       TTypeList = array [0 .. {$ifdef FPC} MaxInt div SizeOf(T) - 1 {$else} 1000 * 1000 {$endif}] of T;
       PTypeList = ^TTypeList;
 
@@ -70,15 +70,15 @@ type
 
       See the @link(List) description for a more detailed explanation and example.
       @seealso List }
-    function L: PT;
+    function L: PtrT;
 
     { Increase Count and return pointer to new item.
       Comfortable and efficient way to add a new item that you want to immediately
       initialize. }
-    function Add: PT; overload;
+    function Add: PtrT; overload;
 
     { Pointer to ith item. }
-    function Ptr(I: Integer): PT;
+    function Ptr(I: Integer): PtrT;
 
     procedure Assign(const Source: TStructList {$ifndef CASTLE_OBJFPC}<T>{$endif}); overload;
     procedure Assign(const A: array of T); overload;
@@ -101,18 +101,18 @@ begin
   Result := PTypeList({$ifdef FPC} FItems {$else} inherited List {$endif});
 end;
 
-function TStructList{$ifndef CASTLE_OBJFPC}<T>{$endif}.L: PT;
+function TStructList{$ifndef CASTLE_OBJFPC}<T>{$endif}.L: PtrT;
 begin
-  Result := PT({$ifdef FPC} FItems {$else} inherited List {$endif});
+  Result := PtrT({$ifdef FPC} FItems {$else} inherited List {$endif});
 end;
 
-function TStructList{$ifndef CASTLE_OBJFPC}<T>{$endif}.Add: PT;
+function TStructList{$ifndef CASTLE_OBJFPC}<T>{$endif}.Add: PtrT;
 begin
   Count := Count + 1;
   Result := Addr(List^[Count - 1]);
 end;
 
-function TStructList{$ifndef CASTLE_OBJFPC}<T>{$endif}.Ptr(I: Integer): PT;
+function TStructList{$ifndef CASTLE_OBJFPC}<T>{$endif}.Ptr(I: Integer): PtrT;
 begin
   Result := Addr(List^[I]);
 end;
diff --git a/src/x3d/x3dnodes_standard_time.inc b/src/x3d/x3dnodes_standard_time.inc
index b32e9bd..d6d694e 100644
--- a/src/x3d/x3dnodes_standard_time.inc
+++ b/src/x3d/x3dnodes_standard_time.inc
@@ -195,12 +195,13 @@
   TAbstractTimeDependentNode = class(TAbstractChildNode, IAbstractTimeDependentNode)
   strict private
     FInternalTimeDependentHandler: TInternalTimeDependentHandler;
-    { To satify IAbstractTimeDependentNode }
-    function GetInternalTimeDependentHandler: TInternalTimeDependentHandler;
   strict protected
     { CycleInterval that is always > 0. }
     function SafeCycleInterval: TFloatTime;
   public
+    { To satify IAbstractTimeDependentNode }
+    function GetInternalTimeDependentHandler: TInternalTimeDependentHandler;
+
     procedure CreateNode; override;
     destructor Destroy; override;
 
diff --git a/src/x3d/x3dtime.pas b/src/x3d/x3dtime.pas
index 76d51da..a388fcc 100644
--- a/src/x3d/x3dtime.pas
+++ b/src/x3d/x3dtime.pas
@@ -74,8 +74,7 @@ type
     Seconds: TFloatTime;
     PlusTicks: Cardinal;
 
-    const
-      Oldest: TX3DTime = (Seconds: OldestTime; PlusTicks: 0);
+    class function Oldest: TX3DTime; static;
 
     class operator {$ifdef FPC}>{$else}GreaterThan{$endif} (const Time1, Time2: TX3DTime): boolean;
     class operator {$ifdef FPC}>={$else}GreaterThanOrEqual{$endif} (const Time1, Time2: TX3DTime): boolean;
@@ -95,6 +94,13 @@ type
 
 implementation
 
+class function TX3DTime.Oldest: TX3DTime; static;
+const
+  R: TX3DTime = (Seconds: OldestTime; PlusTicks: 0);
+begin
+  Result := R;
+end;
+
 class operator TX3DTime.{$ifdef FPC}>{$else}GreaterThan{$endif} (const Time1, Time2: TX3DTime): boolean;
 begin
   Result := (Time1.Seconds > Time2.Seconds) or
diff --git a/tools/build-tool/code/toolproject.pas b/tools/build-tool/code/toolproject.pas
index b6a8e19..7037700 100644
--- a/tools/build-tool/code/toolproject.pas
+++ b/tools/build-tool/code/toolproject.pas
@@ -321,7 +321,7 @@ constructor TCastleProject.Create(const APath: string);
           (QualifiedName[Length(QualifiedName)] = '.')) then
         raise Exception.CreateFmt('%s (in CastleEngineManifest.xml) cannot start or end with a dot: "%s"', [OptionName, QualifiedName]);
 
-      Components := SplitString(QualifiedName, '.');
+      Components := CastleStringUtils.SplitString(QualifiedName, '.');
       try
         for I := 0 to Components.Count - 1 do
         begin
@@ -1662,7 +1662,7 @@ var
   PreviousMacros: array of TStringStringMap.TDictionaryPair;
 begin
   { calculate version as 4 numbers, Windows resource/manifest stuff expect this }
-  VersionComponentsString := SplitString(Version, '.');
+  VersionComponentsString := CastleStringUtils.SplitString(Version, '.');
   try
     for I := 0 to High(VersionComponents) do
       if I < VersionComponentsString.Count then
